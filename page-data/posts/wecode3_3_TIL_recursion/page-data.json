{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/wecode3_3_TIL_recursion/","webpackCompilationHash":"ae87ee1a9b4c8b246693","result":{"data":{"markdownRemark":{"id":"bb6d8e7c-8458-5232-97b6-d2b4cfde0355","html":"<p><img src=\"https://images.velog.io/post-images/dooreplay/90548c30-c1a7-11e9-a617-2b7b8642c92b/mathematics-696806640.png\" alt=\"mathematics-696806_640.png\"></p>\n<p>학창시절.. 수학시간에 프랙탈이라는 구조에 대해서 한번쯤은 들어봤을 것이다. 동일한 모양이 계속해서 반복되는 그러한 구조…!! 사진 속 시에르핀스키 피라밋처럼!\n프로그래밍 세계에서도 동일한 함수가 계속 반복되는 재귀(Recursion)라는 개념이 있다.</p>\n<h2 id=\"왜-재귀를-공부해야-할까\"><a href=\"#%EC%99%9C-%EC%9E%AC%EA%B7%80%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"왜 재귀를 공부해야 할까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 재귀를 공부해야 할까?</h2>\n<ul>\n<li>간결하고 직관적인 코드를 제공한다!</li>\n<li>설계와 개발, 디버깅 과정모두 재귀적인 사고를 요구한다!</li>\n</ul>\n<h2 id=\"재귀란\"><a href=\"#%EC%9E%AC%EA%B7%80%EB%9E%80\" aria-label=\"재귀란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀란?</h2>\n<ul>\n<li>자기 자신을 호출하는 행위</li>\n<li>주어진 문제를 자기 반복적인 문제들로 잘게 분해한 후, 이들을 다시 조합해 원래 문제의 정답을 찾는 것을 말한다~</li>\n</ul>\n<h2 id=\"재귀와-콜스택\"><a href=\"#%EC%9E%AC%EA%B7%80%EC%99%80-%EC%BD%9C%EC%8A%A4%ED%83%9D\" aria-label=\"재귀와 콜스택 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀와 콜스택</h2>\n<ul>\n<li>스택(Stack)이란?</li>\n</ul>\n<p>-함수를 호출한 후 원래 자리로 돌아오려면, ‘원래 자리’를 어딘가에 저장해야하는데 그 어딘가를 가리켜 Stack이라고 한다.</p>\n<ul>\n<li>호출스택(Call Stack)이란?</li>\n</ul>\n<p>-프로그램상 어디에 있는지 기록하는 자료구조를 말한다</p>\n<p>cf) MDN 호출스택 정의 : <a href=\"https://developer.mozilla.org/ko/docs/Glossary/Call_stack\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.mozilla.org/ko/docs/Glossary/Call_stack</a></p>\n<p>-함수를 실행하면 stack위에 push를 하게 됩니다.(쌓이고~)<br>\n-return 시 stack의 맨 윗값(가장 최근 데이터)을 pop합니다.(가져오면 그 함수가 cal l stack에서 제거됩니다.)</p>\n<p>==> 그래서 return 이란~!</p>\n<p>Stack에 저장된 최근 주소값, 나를 실행시킨 것의 바로 다음 step의 주소로 돌아간다는 의미입니다.</p>\n<p><a href=\"https://www.notion.so/8a5620f6efe44958bd1670e6a630869f#b6a59504701d43c4a392b08bbafdef12\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"></a></p>\n<p><img src=\"https://lh3.googleusercontent.com/p4qNK6maB5eamv9M-g3ca_wKdRwe7iDddOLA5fEkTJPlgaRGj8qD2AJ8nGetZJNsbOcV6yHH1BtPf7-IjCyWuIX_E8FWCEFGy_vO7yfLF5FgoW3iYg-Wb4ACiGmYC1L4PtIW1Gr9\"></p>\n<ul>\n<li>Stack Overflow</li>\n</ul>\n<p><img src=\"https://lh4.googleusercontent.com/2QGahcO74QQDksY8oSaCU3bPpEjHIsKFiD9IlXra6KDaZAOs4ACZpPwcMOrW2r_lrvPTZdGVjjrT47XWOfVsbsBdVmIwvykFVqsWf5nrRvbSrLT2EmHiDo_onifjUJvVBWlOCTrP\"></p>\n<p><img src=\"https://lh5.googleusercontent.com/1XVkduAkp0ku6LOZiFPNbLLOpnHCko4oBo9uRx6vGPKQx3YHk9xnLo_viYWCxjzgby57cDWK81n5RvgI9bO_KsP5cN4_vjJr1bQUCBFC_LiBoHgfLWpAbd6zvyAKZtk6mrkk79_K\"></p>\n<p>-값이 return 되기 전에 call stack이 쌓이면 호출스택의 최대 수용치를 넘게 되고… stack overflow 발생!!<br> -종료조건을 달아줘야 stack overflow를 막을 수 있다.</p>\n<h2 id=\"재귀함수-응용\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%EC%9D%91%EC%9A%A9\" aria-label=\"재귀함수 응용 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수 응용</h2>\n<p><img src=\"https://images.velog.io/post-images/dooreplay/6b145840-c1a9-11e9-abb1-7bd155a4a0a8/cute-2500929640.jpg\" alt=\"cute-2500929_640.jpg\"></p>\n<p><strong>&#x3C;1>피보나치 수열</strong></p>\n<ul>\n<li>첫 달은 아기 토끼 한 쌍에서 시작합니다.</li>\n<li>아기 토끼는 한 달이 지나면 어른토끼가 됩니다.</li>\n<li>어른 토끼는 한 달에 한 쌍의 아기토끼를 낳습니다.</li>\n</ul>\n<p>==> 0,1,1,2,3,5,8 …\n위의 결과가 나오도록 함수를 만들어 보면.. 🙂</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    function fibo(n) {\n        if (n &lt; 2)\n            return n;\n        return fibo(n-1) + fibo(n-2);\n    }\n\n    fibo(6) // 8</code></pre></div>\n<p>제가 이 코드를 칠 때 우리의 컴퓨터우리의 컴퓨터는…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    call fibonacci(6)\n      call fibonacci(5)\n        call fibonacci(4)\n          call fibonacci(3)\n            call fibonacci(2)\n              call fibonacci(1)\n              return 1\n              call fibonacci(0)\n              return 0\n            return 1\n            call fibonacci(1)\n            return 1\n          return 2\n          call fibonacci(2)\n            call fibonacci(1)\n            return 1\n            call fibonacci(0)\n            return 0\n          return 1\n        return 3\n        call fibonacci(3)\n          call fibonacci(2)\n            call fibonacci(1)\n            return 1\n            call fibonacci(0)\n            return 0\n          return 1\n          call fibonacci(1)\n          return 1\n        return 2\n      return 5\n      call fibonacci(4)\n        call fibonacci(3)\n          call fibonacci(2)\n            call fibonacci(1)\n            return 1\n            call fibonacci(0)\n            return 0\n          return 1\n          call fibonacci(1)\n          return 1\n        return 2\n        call fibonacci(2)\n          call fibonacci(1)\n          return 1\n          call fibonacci(0)\n          return 0\n        return 1\n      return 3\n    return 8</code></pre></div>\n<p>위의 식으로 6번째 피보나치 수를 구하는데 무려 함수의 호출이 25번 일어납니다 ㅠㅠ..\n14번째 피보나치 수를 구할땐 호출수는 1019…</p>\n<p>console.log(fibo(100)) 을 찍어보면 함수의 호출이 몇 번 일어날까요? (컴퓨터 살려…)</p>\n<h2 id=\"재귀함수의-문제점\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"재귀함수의 문제점 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수의 문제점</h2>\n<ul>\n<li>함수 호출의 비용</li>\n<li>Stack의 깊이</li>\n</ul>\n<p>그렇다면 해결책은 없을까요…?!</p>\n<h2 id=\"해결책--함수-호출하지말고-반복문-쓰기\"><a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85--%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%ED%95%98%EC%A7%80%EB%A7%90%EA%B3%A0-%EB%B0%98%EB%B3%B5%EB%AC%B8-%EC%93%B0%EA%B8%B0\" aria-label=\"해결책  함수 호출하지말고 반복문 쓰기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결책 : 함수 호출하지말고 반복문 쓰기</h2>\n<p>-반복 단계별 계산 결과를 반복이 끝날 때까지 특정 변수에 저장하는 방식으로 풀어볼 수 있습니다~</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    function fibo(n) {\n    var cur, pre = 1, prepre = 0;\n    if (n &lt; 2)\n    return n;\n    for ( var i = 2 ; i &lt;= n ; i++ ) {\n    cur = pre + prepre;\n    prepre = pre;\n    pre = cur;\n    }\n    return cur;\n    }</code></pre></div>\n<p>또 다른 해결책으론 꼬리호출이라는 방식이 있는데.. 이건 제가 아직 제대로 이해하지 못해서 다음 기회에…<br>\n아직 이 방식을 적용하는 브라우저도 많지 않아서 천천히 알아도 될 것 같고요..?</p>\n<h2 id=\"재귀함수-활용한-알고리즘-문제들\"><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"재귀함수 활용한 알고리즘 문제들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀함수 활용한 알고리즘 문제들</h2>\n<p>전체코드를 다 보기 전에 타이틀만 보고 꼭 한번씩 생각해보세요~</p>\n<h2 id=\"최소공배수와-최대공약수-구하기\"><a href=\"#%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98%EC%99%80-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"최소공배수와 최대공약수 구하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최소공배수와 최대공약수 구하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function solution(n, m) {\n  function u(n, m) { return m % n ? u(m % n, n) : n; }\n  const gcd = u(n, m);\n  return [gcd, n * m / gcd];\n}</code></pre></div>\n<p>유클리드 호제법이라는 것도 한번 찾아보세요~ 아직도 너무 너무 헷갈리는 이 공식 ㅠㅠ</p>\n<h2 id=\"문자열-반복하기\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0\" aria-label=\"문자열 반복하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 반복하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function repeatString(string, num) {\n  if(num &lt;= 0) {\n    return &#39;&#39;\n  }\n  else {\n    return string + repeatString(string,num-1)\n  }\n}</code></pre></div>\n<h2 id=\"주어진-두-수-사이의-숫자들-구하기\"><a href=\"#%EC%A3%BC%EC%96%B4%EC%A7%84-%EB%91%90-%EC%88%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%88%AB%EC%9E%90%EB%93%A4-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"주어진 두 수 사이의 숫자들 구하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주어진 두 수 사이의 숫자들 구하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const range = (start = 0, end = 0) =&gt; {\n  let arr = [];\n  start &gt; end &amp;&amp; ([start, end] = [end, start]);\n  arr.push(start);\n  return start === end ? arr : [...arr, ...range(start + 1, end)]\n}\nconsole.log(range(2, 5)); // [2, 3, 4, 5]</code></pre></div>\n<h2 id=\"n번째-짝수-구하기\"><a href=\"#n%EB%B2%88%EC%A7%B8-%EC%A7%9D%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"n번째 짝수 구하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>N번째 짝수 구하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getNthEvenNum (n) {\n    if (n &lt;= 1) {\n        return 0;\n    } else {\n        return getNthEvenNum(n-1) + 2;\n    }\n};\n\ngetNthEvenNum(3) //4\n//0,2,4,6,8,10,12...</code></pre></div>\n<h2 id=\"특정숫자의-n제곱-구하기\"><a href=\"#%ED%8A%B9%EC%A0%95%EC%88%AB%EC%9E%90%EC%9D%98-n%EC%A0%9C%EA%B3%B1-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"특정숫자의 n제곱 구하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특정숫자의 n제곱 구하기</h2>\n<p>아래의 코드는 2의 n제곱이지만 다른 숫자를 넣으면 그 수의 제곱을 구할수 있겠죠? :)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getPowerOf2 (n) {\n  if(n) &lt;=0) {\n    return 1\n  }\n  else {\n    return getPowerOf2(n-1)*2\n  }\n}\n\ngetPowerOf2(4)//16</code></pre></div>\n<h2 id=\"순차검색법\"><a href=\"#%EC%88%9C%EC%B0%A8%EA%B2%80%EC%83%89%EB%B2%95\" aria-label=\"순차검색법 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순차검색법</h2>\n<p>이건 아직도 헷갈려서 이번에 정리하는 김에 다시 보고 있어요~</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function searchArraySequentially (array, i, j, x) {\n    if (i &lt;= j) {\n        if (array[i] === x) { // 같으면 i return\n            return i;\n        } else { //같지 않으면 하나씩 늘려서 간격 줄여가기\n            return searchArraySequentially(array, i + 1, j, x);\n        }\n    } else { //끝까지 줄였는데도 안 나오면 i와j사이에 없는거니깐 -1 return\n        return -1;\n    }\n}\n\nvar array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];\nvar result1 = searchArraySequentially(array, 0, 4, &#39;e&#39;);\nvar result2 = searchArraySequentially(array, 0, 3, &#39;e&#39;);</code></pre></div>\n<h2 id=\"문자열-역순으로-정리하기\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%AD%EC%88%9C%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0\" aria-label=\"문자열 역순으로 정리하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 역순으로 정리하기</h2>\n<p>거꾸로 하는건 reverse지만.. 언어유희 좀 해봤어요 ㅎ 이 코드를 알고있어서 위코드 1주차 코드카타 문제를 재귀로도 접근해볼수 있었네요~</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function rebirth(s) {\n  if(s === &#39;&#39;) {\n    return &#39;&#39;\n  }\n  else {\n    return rebirth(s.substring(1))+s.charAt(1)\n  }\n}\nconsole.log(rebirth(&#39;hello&#39;))\n//ello + h\n//llo + e + h\n//lo + l + e + h\n//o + l + l + e+ h</code></pre></div>\n<p>이렇게 재귀에 대해 간단히 알아보았는데요..!\n개발자라면 피할 수 없는 부분이라고 생각합니다.. 탈출조건을 생각하고 로직을 짜는게 참 어려운 일이지만..<br> 익숙해지면 잘 할수 있겠죠???!ㅋㅋ</p>\n<h2 id=\"reference\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://ryulib.tistory.com/318\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ryulib.tistory.com/318</a></li>\n<li><a href=\"https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/</a></li>\n</ul>\n<p>원래 출처가 몇 군데 더 있었는데.. 예전에 에버노트에서 한번 날리는 바람에…ㅠㅠ<br>\n출처 중 두번째 블로그는 읽어보시면 꼭 도움 될겁니다!</p>","fields":{"slug":"/posts/wecode3_3_TIL_recursion/","tagSlugs":["/tag/wecode/","/tag/codingbootcamp/","/tag/recursion/","/tag/위코드/"]},"frontmatter":{"date":"2019-08-14T09:40:32.169Z","description":"위코드 17일차. 코딩을 하면서 꼭 한번쯤은 맞딱뜨리게 되는 재귀함수에 대해 정리해보았다!","tags":["wecode","codingbootcamp","recursion","위코드"],"title":"wecode 3주차_3일 TIL_재귀함수(Recursion)에 대해 정리해보기"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/wecode3_3_TIL_recursion/"}}}