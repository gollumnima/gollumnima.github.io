{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/wecode10_6TIL_object_ref","webpackCompilationHash":"458b405b709d8c919f0e","result":{"data":{"markdownRemark":{"id":"25ca0268-73d6-54ad-88d5-99b10f10a44c","html":"<p><img src=\"https://images.velog.io/post-images/dooreplay/00a54810-e707-11e9-973a-55350a1abd48/image.png\" alt=\"image.png\"></p>\n<p>한번쯤은 짚고넘어가야 했던 부분인데 이제서야 정리해본다!<br />\n깊은 복사와 얕은 복사는 뭘까?</p>\n<h2 id=\"string-number-boolean에서의-복사\"><a href=\"#string-number-boolean%EC%97%90%EC%84%9C%EC%9D%98-%EB%B3%B5%EC%82%AC\" aria-label=\"string number boolean에서의 복사 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String, Number, Boolean에서의 복사</h2>\n<p>먼저 예제부터 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let x = &#39;마카롱&#39;\nlet y = x\ny = &#39;바게트&#39;\nconsole.log(x,y)</code></pre></div>\n<p>다음과 같은 식에서 y에 x를 대입해서 y는 마카롱이 되었지만\ny에 또다시 바게트라는 값을 대입했기 때문에 콘솔을 찍어보면\n<code class=\"language-text\">마카롱,바게트</code> 라는 결과가 나오게 된다.</p>\n<p>y의 값은 변해도 x의 값엔 영향을 주지 않는다</p>\n<p><img src=\"https://images.velog.io/post-images/dooreplay/878de9d0-e708-11e9-9db5-fda9d04b0052/image.png\" alt=\"image.png\"></p>\n<p>변수는 모두 메모리의 어딘가에 저장이 되는데, 대입을 하면 그 변수의 이름은 저장된 메모리의 주소를 가리킨다.\n객체 말고 string, boolean, number들은 딱 그 값을 복사하는데\n객체 같은 경우는 좀 다르다.\n배열 또한 객체기 때문에 예시를 배열로 들어보았다~</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let arr = [1,2,3]\nlet plus = arr;\nplus[0]=0;\nconsole.log(arr);\nconsole.log(plus);</code></pre></div>\n<p>위의 코드를 콘솔에 찍어보면 둘 다 [0,2,3]이 나온다.\n메모리에 [1,2,3]이라는 값을 가진 애는 arr와 plus 둘.\n값은 하나인데 변수가 여러개일 때 이것을 참조라고 한다.<br />\n마치 내 이름이 김두리지만 둘둘이라던지 킹둘이라던지 별명이 많은 것처럼 훗<br />\n동일한 값에 변수가 여러개기 때문에 변수가 바뀌면 원본도 바뀌게 된다!<br />\n이걸 방지하려면 메모리에 한 값당 한 변수씩! 할당을 해줘야한다.</p>\n<h2 id=\"복사\"><a href=\"#%EB%B3%B5%EC%82%AC\" aria-label=\"복사 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복사</h2>\n<p>여기서 나오는게 바로 복사라는 개념이다.</p>\n<ul>\n<li>얕은 복사 : 상위객체만 새로 생성되고 내부 객체는 참조관계</li>\n<li>깊은 복사 : 내부객체까지 전부 다 새로 생성되는 것</li>\n</ul>\n<h2 id=\"예제\"><a href=\"#%EC%98%88%EC%A0%9C\" aria-label=\"예제 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let profile = {\n  name: &quot;김개발&quot;,\n  address: {\n    home: &quot;한강아파트&quot;,\n    company: &quot;위워크 선릉2호점&quot;\n  },\n  hobby: &quot;programming&quot;\n}\n\nconst addProperty = info =&gt; {\n}\n\n// 호출 예\nlet newProfile = addProperty({ age: 20 });\nconsole.log(&#39;profile =&gt; &#39;, profile);\nconsole.log(&#39;newProfile =&gt;&#39;, newProfile);</code></pre></div>\n<p>addProperty 라는 함수를 통해 newProfile에는 새로운 값이 추가되어야 하고, 원본 객체는 손상시키면 안된다.</p>\n<h2 id=\"내가-접근한-방법\"><a href=\"#%EB%82%B4%EA%B0%80-%EC%A0%91%EA%B7%BC%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"내가 접근한 방법 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내가 접근한 방법</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addProperty = info =&gt; {\n  const sth_new = {}\n  for(let i in profile) {\n    sth_new[i] = profile[i]\n  }\n  return Object.assign(sth_new, info)\n}</code></pre></div>\n<p>먼저 sth<em>new라는 빈 객체를 만들고 for in 문을 돌려서\nprofile의 값들을 다 빈 객체에 옮겼고,\n리턴 값으론 Object.assign을 이용해 인자를 들어가는 info와 sth</em>new를 merge시켜주었다.</p>\n<p>근데 굳이 for in 문을 안 돌려도 됐던 것..!!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addProperty = info =&gt; {\n  const copyProperty = Object.assign({}, profile);\n  return Object.assign(copyProperty, info)\n}</code></pre></div>\n<p>그냥 새 객체를 Object.assign()을 이용해 선언해주고\n리턴에 그걸 한번 더 써서 info를 넣어주면 됐다 헐~~</p>\n<p>더 간단하게는</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addProperty = info =&gt; {\n  return {\n    ...info,\n    ...profile\n  }\n}</code></pre></div>\n<p>세상에… 전개연산자로 한큐에 끝낼수 있다\n전개연산자를 한정적으로만 써서 이런 기능이 있을줄 몰랐다</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">MDN 전개연산자</a>에서 딱 처음 두개,\napply 대신이랑 new와 함께 쓰는 것만 해봤는데 복사에 이렇게 유용하게 쓰이다닛..! 자주 활용해봐야겠다.</p>\n<p>더 고난이도 방법으론 재귀를 쓰는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addProperty = info =&gt; {\n let newProfile = {};\n // recursion\n function copyObject(data, newData){\n   let typeOfInputData = typeof(data);\n   if(typeOfInputData != &#39;object&#39;){\n       return data;\n   }\n   else{\n     for(let key in data){\n         let typeOfData = typeof(data[key]);\n         if(typeOfData === &#39;object&#39;){\n          if(Array.isArray(data[key])){\n               newData[key] = [];\n           }\n           else{\n               newData[key] = {};\n           }\n           copyObject(data[key], newData[key]);\n         }\n         else{\n           newData[key] = data[key];\n         }\n     }\n   }\n   return newData;\n }\n // 원본 복사\n copyObject(profile, newProfile);\n // 객체 추가\n copyObject(info, newProfile);\n return newProfile;\n}</code></pre></div>\n<p>우리 기수 동기인 광훈님의 방법..\n와… 정말 어나더 클래스 대단쓰\n이걸 재귀로 생각할 수 있었다니 와… 그저 감탄만 나온다</p>\n<p>하나의 주제에 대해 서로 다양한 방법으로 생각해볼 수 있는 좋은 시간이었다!\n다음 주제는 무엇이 될지 궁금하군 룰루~♬</p>\n<h2 id=\"reference\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>wecode repl.it</li>\n<li>MDN</li>\n</ul>","fields":{"slug":"/posts/wecode10_6TIL_object_ref","tagSlugs":["/tag/wecode/","/tag/codingbootcamp/","/tag/javascript/","/tag/es-6/","/tag/위코드/"]},"frontmatter":{"date":"2019-10-05T10:06:23.169Z","description":"위코드 68일차. 현재 Next.js 초기 세팅 하는 법을 열심히 정리중인데 아직 완성은 못했다. 마침 위코드에서 하루에 한 주제씩 자바스크립트에 대해 생각해볼 문제를 던져주셔서 푸는중! 오늘은 그 첫 단계, 깊은 복사와 얕은 복사 그리고 객체의 참조에 대해 써보았다!","tags":["wecode","codingbootcamp","javascript","ES6","위코드"],"title":"wecode 10주차_6일 TIL_깊은 복사와 얕은 복사 그리고 객체의 참조"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/wecode10_6TIL_object_ref"}}}