{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/wecode7_4TIL_Lifecyle","webpackCompilationHash":"904934329d42a9e48021","result":{"data":{"markdownRemark":{"id":"bb0c1b12-88c6-5320-b86e-0aa65d70b274","html":"<p><img src=\"https://images.velog.io/post-images/dooreplay/695d77d0-d431-11e9-8e96-67f3919bbc9b/image.png\" alt=\"image.png\">\n(출처 : 대한민국 법제처)</p>\n<p>거지와 노예를 반복하는 인간의 인생처럼 리액트에도 Life Cycle이 존재한다!\n지금부터 리액트세상에서의 라이프사이클이 무엇인지 알아보도록 하자!</p>\n<h1 id=\"life-cycle\"><a href=\"#life-cycle\" aria-label=\"life cycle permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Life cycle</h1>\n<p>컴포넌트가 생성되서 사용되고 소멸될때까지의 과정을 Life Cycle이라고 한다.\n아래의 그림을 한번 살펴보면 크게 세 단계로 나눌수 있는데..\n<img src=\"https://images.velog.io/post-images/dooreplay/4ecbe080-d3bb-11e9-b310-6b6bd497ab3a/image.png\" alt=\"image.png\">\n(출처 :<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a>)</p>\n<h2 id=\"mount-초기화-단계\"><a href=\"#mount-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%8B%A8%EA%B3%84\" aria-label=\"mount 초기화 단계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mount (초기화 단계)</h2>\n<p>컴포넌트가 처음 실행될 때\n<code class=\"language-text\">constructor → getDerivedStateFromProps → render → componentDidMount</code> 순으로 작동!</p>\n<h3 id=\"constructor\"><a href=\"#constructor\" aria-label=\"constructor permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor</h3>\n<ul>\n<li>컴포넌트가 처음 생성될 때.</li>\n<li>여기서 state와 props의 기본값 설정.</li>\n<li>props 넘길때 꼭 super안에 props를 넣어줘야 함!</li>\n<li>this.state 객체를 직접 할당할 수 있는 유일한 곳. 다른 곳에선 this.setState()를 써야함.</li>\n</ul>\n<h3 id=\"static-getderivedstatefrompropspropsstate\"><a href=\"#static-getderivedstatefrompropspropsstate\" aria-label=\"static getderivedstatefrompropspropsstate permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>static getDerivedStateFromProps(props,state)</h3>\n<ul>\n<li>props에 있는 값을 state로 동기화 할 때 씀.</li>\n<li>시간에 따라 변하는 props로부터 state값을 계산할 때 씀(애니메이션)</li>\n<li>이걸 이용해 메모이제이션 구현도 가능</li>\n<li>어떤객체를 넣어주면 state값이 됨.\n여기서 메모이제이션이란 이전에 연산한 결과를 저장하고 있는 객체를 사용하는 최적화 기법을 말하는데..\n아직 어렵고 이해 안 가는 부분이라 일단 패쓰!</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.value != prevState.value) {\n      return { value: nextProps.value };\n    }\n    return null;\n  }</code></pre></div>\n<p>코드는 이러하다.. 그치만 나는 이번 프로젝트에서 props 값을 state로 동기화시킬만한 코드가 없어서 실제로 적용은 못해보았다.</p>\n<h3 id=\"render\"><a href=\"#render\" aria-label=\"render permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>render()</h3>\n<ul>\n<li>컴포넌트가 리액트 세상에 존재함을 알리는 단계! 우리가 작성한 코드를 랜더링함.</li>\n<li>콘솔도 여기서 찍얼 볼 수 있음. 리턴 다음에 찍을 수 없어~</li>\n</ul>\n<h3 id=\"componentdidmount\"><a href=\"#componentdidmount\" aria-label=\"componentdidmount permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidMount()</h3>\n<ul>\n<li>API 호출할 수 있는 곳</li>\n<li>이 단계에서 setState를 호출하면 다시 랜더링 됨.</li>\n</ul>\n<h2 id=\"update-업데이트-단계\"><a href=\"#update-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%8B%A8%EA%B3%84\" aria-label=\"update 업데이트 단계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Update (업데이트 단계)</h2>\n<p>state나 props가 업데이트 되는 단계\n<code class=\"language-text\">getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate</code> 순으로 작동!</p>\n<p>위에서 정리한 개념은 패쓰~ 새로운 것들만 개념정리 고고!</p>\n<h3 id=\"shouldcomponentupdatenextprops-nextstate\"><a href=\"#shouldcomponentupdatenextprops-nextstate\" aria-label=\"shouldcomponentupdatenextprops nextstate permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>shouldComponentUpdate(nextProps, nextState)</h3>\n<ul>\n<li>props와 state의 값이 변하면 true, 아니면 false를 리턴함</li>\n<li>true일 경우 render되고, false일 경우 업데이트 중단. 기본값은 true이다!</li>\n<li>이건 지극히 성능최적화를 위함..</li>\n</ul>\n<p>이거 대신 Pure Component를 써도 된다.\nPure Component 안에 자동으로 shouldComponentUpdate가 적용이 된다고 한다. 아직 슈컴업도 제대로 이해가 안 된 상태라 이거와 동일한 방식의 퓨어컴포넌트는 일단 Reference에 괜찮은 사이트를 걸어놨다.. 좀 더 공부하다보면 둘 다 뭔지 정확하게 알게 되겠지..</p>\n<p>여튼 Home의 자식 컴포넌트인 BestRecipe 컴포넌트에 슈컴업을 적용해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> shouldComponentUpdate(nextProps) {\n    return nextProps.el !== this.props.el;\n  }</code></pre></div>\n<p>현재 props의 element와 다음 props의 element가 다르다는 것을 리턴..</p>\n<p><img src=\"https://images.velog.io/post-images/dooreplay/64b62ed0-d54d-11e9-977b-75c190e82cde/image.png\" alt=\"image.png\"></p>\n<p>화면에 레시피정보가 뜨지 않는걸 보아하니, 업데이트 종료인것이고.. false라는 건데\n그럼 현재의 props와 그 다음 props 값이 같다는 건가보다..!\n저기서 !==을 ===으로 바꾸면 정상적으로 레시피정보가 뜬다.</p>\n<p>그래도 콘솔에 props를 찍어보면 8개나 찍혀서…(하나당 4개씩)\n랜더링이 계속 되는거 보면 식을 코드를 잘못 적용한것 같아서 위코드 전용 스택오버플로우에 물어보고있다!</p>\n<h3 id=\"getsnapshotbeforeupdateprevprops-prevstate\"><a href=\"#getsnapshotbeforeupdateprevprops-prevstate\" aria-label=\"getsnapshotbeforeupdateprevprops prevstate permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>getSnapshotBeforeUpdate(prevProps, prevState)</h3>\n<ul>\n<li>랜더링 한 다음에 그 결과물이 브라우저에 반영되기 직전에 호출됨</li>\n<li>여기서 반환되는 값은 componentDidUpdate의 세번째 인자로 전달됨.</li>\n<li>이건 아직까진 잘 안 쓰는 것 같아서 정보가 많이 없다 ㅠㅠ 나중에 쓰게 되면 다시 포스팅 해봐야지!</li>\n</ul>\n<h3 id=\"componentdidupdateprevprops-prevstate\"><a href=\"#componentdidupdateprevprops-prevstate\" aria-label=\"componentdidupdateprevprops prevstate permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidUpdate(prevProps, prevState)</h3>\n<ul>\n<li>업데이트 단계의 마지막 메소드!</li>\n<li>업데이트된 돔의 state를 가장 빠르게 가져올 수 있는 메소드..!</li>\n<li>컴포넌트 업데이트 이후 DOM을 조작해야 할 때 사용</li>\n</ul>\n<h2 id=\"unmount-소멸-단계\"><a href=\"#unmount-%EC%86%8C%EB%A9%B8-%EB%8B%A8%EA%B3%84\" aria-label=\"unmount 소멸 단계 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmount (소멸 단계)</h2>\n<h3 id=\"componentwillunmount\"><a href=\"#componentwillunmount\" aria-label=\"componentwillunmount permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillUnmount</h3>\n<ul>\n<li>소멸 단계의 유일무이한 메소드!</li>\n<li>끝나지 않는 네트워크 요청 취소, 타이머 해제, 구독 해제 등의 작업할 때 쓴다고 한다</li>\n</ul>\n<p>이거 약간 어디에 써야할 지 알것 같은데…\n예전에 html과 js로 게임 만들기 했을 때 유령이 화면상에선 바닥에 머무르지만, 콘솔창에서의 실제적인 숫자는 계속적으로 증가하는 그런 문제가 있었는데..\n거기에 적용하면 될것 같다! 근데… 지금 리액트로 게임화면 구현하기엔 시간이 벅찰것 같아 생략쓰..☆</p>\n<h2 id=\"ref\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref</h2>\n<p>헐 소름… Ref를 한글로 치면 ㄱㄷㄹ.. 내 이니셜이다 ㅋㅋ</p>\n<ul>\n<li>리액트에서 component나 element의 id 역할을 하는게 바로 Ref</li>\n<li>작업중인 부모 컴포넌트에서 ref를 통해 자식요소를 쉽게 호출 가능쓰!</li>\n<li>ref 남용 금지! 최대한 state와 props를 이용하는게 유지보수에 좋음</li>\n</ul>\n<p>1차 프로젝트에서 어떻게 적용하는지 모르겠어서 제로초님의 강의를 봤다..</p>\n<p>input에 focus 효과를 주기 위해\ninput 태그 안에 <code class=\"language-text\">ref = {c =&gt; { this.input = c; }}</code> 라는 값을 입력하고,\ninput 태그가 걸린 함수에는 <code class=\"language-text\">this.input.focus();</code> 라는 함수를 걸어주었다.\n이렇게 하면 마우스 입력이 끝나도 focus 깜빡이가 적용이 된다!</p>\n<p>일단 명절맞이 라이프사이클 정리는 여기서 이렇게 마치고…\n이 부분은 추가적으로 계속 공부하고, 적용해볼 부분을 찾아봐야 이해가 확실히 될것 같다 ㅠㅠ</p>\n<h2 id=\"reference\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>실전 리액트 프로그래밍 (이재승 저)</li>\n<li><a href=\"https://reactjs.org/docs/react-component.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://reactjs.org/docs/react-component.html</a></li>\n<li><a href=\"https://60devs.com/pure-component-in-react.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://60devs.com/pure-component-in-react.html</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=nsS5mbyDDBw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=nsS5mbyDDBw</a></li>\n</ul>","fields":{"slug":"/posts/wecode7_4TIL_Lifecyle","tagSlugs":["/tag/wecode/","/tag/codingbootcamp/","/tag/lifecycle/","/tag/react/","/tag/위코드/"]},"frontmatter":{"date":"2019-09-12T12:51:23.169Z","description":"위코드 38일차. 우리에게 익숙한 constructor, render와 componetDidMount 말고도 리액트는 다양한 라이프 사이클 메소드를 가지고 있다. 오늘은 그 과정에 대해 정리해보았다!","tags":["wecode","codingbootcamp","lifecycle","react","위코드"],"title":"wecode 7주차_4일 TIL_React Lifecyle에 대해 알아보았다"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/wecode7_4TIL_Lifecyle"}}}